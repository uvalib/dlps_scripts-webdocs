#!/usr/bin/perl -w

# img_aspect_ratio - will examine a directory of image files and determine if
#		any images are outside of a standard variance from the desired measurement.

# Jack Kelly <jlk4p@virginia.edu>
# Created: 2007-09-25

#======================================================================
# setup
#======================================================================

use strict;
use Getopt::Long;
use Cwd;
use Image::Magick;

my (%opts, $error, $ok, @outfiles, %infiles);
my ($dir, $id, $infile, $outfile, $command);
my (@errors, @progress, $msg, $gigabytes);

my $me = 'img_aspect_ratio';
my $startDir = cwd();
my $units = 'cm';	# centimeter is the default unit value
my $orientation = 'portrait';	# default is portrait orientation
my $minimumDPI = 600;
my $variance = .10;	# ten percent variance in pixel size is default
my $mailFrom = "jlk4p\@virginia.edu";
my $mailTo = "ul-dlpsscripts\@virginia.edu";

my $usage = <<EOD;

$me - examines a directory of TIFF images to determine if any 
	images are outside of an acceptable variance from the specified image 
	size. An email containing a list of files not meeting the requirements
	specified is generated by this script.

Usage: $me [-v] [-a email[,email]...] [-d minimum] [-m percent] [-f] [-o p|l] [-u cm|in] length directories
  -v (verbose) Show status messages
  -a (address) Email address(es) to send results of analysis. Default is
     ul-dlpsscripts\@virginia.edu if not specified. Separate addresses
     using a comma, not spaces.
  -d (dpi) Expected dpi of images. Anything less than the minimum value
     specified should be reported as a problem. If no minimum is specified,
     the default used is 600.
  -f (file size) Check the file size in addition to the aspect ratio for the 
     image files. All image files are examined and the largest and smallest 
     file sizes are checked to be within the maximum variance specified.
  -m (maximum variance) Indicates the maximum acceptable variance percentage 
     allowed for the longest side of the image file. This variance applies to
     the file size comparison as well if that option is turned on. If this flag 
     is left off, then the default variance is 10%. The percentage should be 
     represented as a decimal number, e.g. 15% should be specified as 0.15
  -o (orientation) Indicates the orientation of the images. Use p for portrait 
     or l for landscape. If this flag is not specified, p(ortrait) is the 
     default.
  -u (units) Specify either cm (centimeters) or in (inches) to identify the
     unit of the longest side of the source. Centimeters is the default unit
     value if none is specified.

In:  Names of directories containing TIFF files to process
Out: The script performs the following actions for each input directory:
       - Checks the aspect ratio of each image compared to that of the source
         used and identifies any image files that do not fall within the 
         maximum allowed.
       - Optionally indicates if file sizes differ beyond the desired variance.

EOD

GetOptions(\%opts,'v', "a=s", "d=i", 'm=f', 'o=s', 'u=s', 'f') || die $usage;
die $usage unless (@ARGV);

$msg = "Started at "  . (scalar localtime) . "\n\n";
push(@progress, $msg);

# Change who the email gets sent to if this option was specified.
if (exists $opts{'a'}) {
	$mailTo = $opts{'a'};
	$msg = "Alternate email address(es) specified for this script: $mailTo\r\n\r\n";
	print $msg if ($opts{'v'});
    push(@progress, $msg);
	$msg = "If you are receiving this email and shoud not have, please forward it to ul-dlpsscripts\@virginia.edu\r\n\r\n";
    push(@progress, $msg);
}

# Change the minimum dpi if this option was specified.
if (exists $opts{'d'}) {
	if ($opts{'d'} =~ /^\d+$/) {
		if ($opts{'d'} ne 0) {
			$minimumDPI = $opts{'d'};
		}
	} else {
		die $usage;
	}
}
$msg = "Minimum DPI set to $minimumDPI\r\n";
print $msg if ($opts{'v'});
push(@progress, $msg);

# Change the maximum variance allowed if it was specified
if (exists $opts{'m'}) {
	if ($opts{'m'} =~ /^-?(?:\d+(?:\.\d*)?|\.\d+)$/) {
		if ($opts{'m'} ne 0.0) {
			$variance = $opts{'m'};
		}
	} else {
		die $usage;
	}
}
$msg = sprintf("Maximum variance set to %4.1f%%\r\n",($variance * 100));
print $msg if ($opts{'v'});
push(@progress, $msg);

# Change the orientation if this option was specified
if (exists $opts{'o'}) {
	if ($opts{'o'} eq 'l') {
		$orientation = 'landscape';
	} elsif ($opts{'o'} eq 'p') {
		$orientation = 'portrait';
	} else {
		die $usage;
	}
}
$msg = "Orientation set to $orientation\r\n";
print $msg if ($opts{'v'});
push(@progress, $msg);

# Change the unit of measurement if this option was specified
if (exists $opts{'u'}) {
	if ($opts{'u'} eq 'in') {
		$units = 'in';
	} elsif ($opts{'u'} eq 'cm') {
		$units = 'cm';
	} else {
		die $usage;
	}
}
$msg = "Unit measurement set to $units\r\n\r\n";
print $msg if ($opts{'v'});
push(@progress, $msg);


#======================================================================
# main logic
#======================================================================

# Length of longest side is first parameter
my $longest_side = $ARGV[0];
my $pixelsLongestSide = sizeInPixels($longest_side,$units,$minimumDPI);
$msg = "Length of longest side set to $longest_side $units ($pixelsLongestSide pixels).\r\n\r\n";
print $msg if ($opts{'v'});
push(@progress, $msg);


# Directories are the rest of the parameters
my @directories = ();
for (my $i=1; $i < scalar(@ARGV); $i++) {
	push(@directories,$ARGV[$i]);
}

# Process each directory passed to the script
foreach $dir (sort(@directories)) {
    $error = 0;
    $ok = 1;
    @outfiles = ();
    %infiles = ();

    $dir =~ s:/$::;  # remove final slash, if present
    $id = $dir;
    $id =~ s:^.*/::;  # remove leading path, if any

    $msg = "$me: Processing directory '$dir' (ID $id)...\r\n";
    print $msg if ($opts{'v'});
    push(@progress, $msg);

    if (-d $dir) {
	unless ( -r $dir ) {
	    $msg = "$me: ERROR: Need read permission for directory '$dir'\r\n";
	    warn $msg;
	    push(@errors, $msg);
	    $ok = 0; next;
	}
    } else {
	$msg = "$me: ERROR: '$dir' is not a directory\r\n";
	warn $msg;
	push(@errors, $msg);
	$ok = 0; next;
    }

    # change to input directory
    if ( not chdir($dir) ) {
	$msg = "$me: ERROR: Cannot change to directory '$dir': $!\r\n";
	warn $msg;
	push(@errors, $msg);
	$ok = 0; next;
    }


    #------------------------------------------------------------------
    # analyze the files in the directory
    #------------------------------------------------------------------
    $msg = "    Looking for TIFF files...\r\n";
    print $msg if ($opts{'v'});
    push(@progress, $msg);
	my @images = ();
    if ( opendir(DIR, '.') ) {
		while ( defined($infile = readdir(DIR)) ) {
			if ( $infile =~ /^\./) {
				next;	# ignore file as it starts with .
			} elsif ($infile =~ /\.tif$/) {
				# process tif file
		 	   push(@images,$infile);
			} elsif ($infile =~ /\.TIF$/) {
				# process TIF file
		    	push(@images,$infile);
			} else {
				next;	# ignore non-TIFF files
			}
		}
		closedir DIR;
    } else {
		$msg = "$me: ERROR: Cannot read directory '$dir': $!\r\n";
		warn $msg;
		push(@errors, $msg);
		$ok = 0; next;
    }

    if ( not scalar(@images) ) {
		$msg = "$me: WARNING: No TIFF files found in directory '$dir'\r\n";
		print $msg;
		push(@progress, $msg);
		next;
    } else {
    	$msg = "        Number of TIFF files found: " . scalar(@images) . "\r\n";
    	push(@progress, $msg);
    }
	
    
    # Determine if any of the image files are corrupt.
    # While processing the directory of images, determine the DPI and space
    # of the files.
	if (scalar(@images) > 0) {
		$msg = "    Examining TIFF files...\r\n";
    	print $msg if ($opts{'v'});
		push(@progress, $msg);
	}
	my ($exception1,$exception2);
	my %fileSizes;
	my $closestPixelSize = 0;
	my $closestFileSize = 0;
	my $fileDPIs;
	my $corruptFile = 0;
    foreach $infile (@images) {
		# Read the image into memory.
		my $image = Image::Magick->new;
		$exception1 = $image->Read("$infile");
		if (($exception1 eq "") or 
			 ((($exception1 =~ m/unknown field with tag/) and 
			 (($exception1 =~ m/ignored/) or ($exception1 =~ m/encountered/))) or 
			 (($exception1 =~ m/incorrect count for field/) and ($exception1 =~ m/tag ignored/)))) {
			
			# Confirm that the file format it TIFF
			if ($image->Get('format')) {				
				# Since this script is intended for TIFF images warn if the file is not this format
				if ($image->Get('format') ne 'Tagged Image File Format') {
					$msg = "        WARNING: $infile does NOT appear to be a TIFF image.\r\n";
					push(@progress, $msg);
				}
				
				# If filesizes are to be compared and within the variance specified, then 
				# save the file size for later use.
				if ($opts{'f'}) {
					$fileSizes{$infile} = $image->Get('filesize');
					if ($orientation eq 'portrait') {
						if (($closestPixelSize < $image->Get('height')) and ($image->Get('height') <= $pixelsLongestSide)) {
							$closestPixelSize = $image->Get('height');
							$closestFileSize = $image->Get('filesize');
						} elsif  (($pixelsLongestSide <= $image->Get('height')) and ($image->Get('height') < $closestPixelSize)) {
							$closestPixelSize = $image->Get('height');
							$closestFileSize = $image->Get('filesize');
						}
					} else { # otherwise landscape
						if (($closestPixelSize < $image->Get('width')) and ($image->Get('width') <= $pixelsLongestSide)) {
							$closestPixelSize = $image->Get('width');
							$closestFileSize = $image->Get('filesize');
						} elsif  (($pixelsLongestSide <= $image->Get('width')) and ($image->Get('width') < $closestPixelSize)) {
							$closestPixelSize = $image->Get('width');
							$closestFileSize = $image->Get('filesize');
						}
					}
				}
				
				my $xResolution = $image->Get('x-resolution');
				my $yResolution = $image->Get('y-resolution');
				if ($xResolution == $yResolution) {
					if ($xResolution < $minimumDPI) {
						$msg = "        WARNING: $infile dpi ($xResolution) is below minimum requirements.\r\n";
						push(@progress, $msg);
					} else { 
					# compare this image's long size to the expected size for the physical item
						my $aspectRatio;
						if ($orientation eq 'portrait') { # use height of image in calculation
							if ($image->Get('height') >= $pixelsLongestSide) {
								if (($image->Get('height') / $pixelsLongestSide) gt (1 + $variance)) {
									$msg = sprintf("        WARNING: $infile exceeds %4.1f%% variance.\r\n",($variance * 100));
									push(@progress, $msg);
								}
							} else {
								if (($pixelsLongestSide / $image->Get('height')) gt (1 + $variance)) {
									$msg = sprintf("        WARNING: $infile exceeds %4.1f%% variance.\r\n",($variance * 100));
									push(@progress, $msg);
								}
							}
						} else {	# else it is landscape: use width of image in calculation
							if ($image->Get('width') >= $pixelsLongestSide) {
								if (($image->Get('width') / $pixelsLongestSide) gt (1 + $variance)) {
									$msg = sprintf("        WARNING: $infile exceeds %4.1f%% variance.\r\n",($variance * 100));
									push(@progress, $msg);
								}
							} else {
								if (($pixelsLongestSide / $image->Get('width')) gt (1 + $variance)) {
									$msg = sprintf("        WARNING: $infile exceeds %4.1f%% variance.\r\n",($variance * 100));
									push(@progress, $msg);
								}
							}
						}
					}
				} else {
					$msg = "        WARNING: $infile contains non-square pixel size.\r\n";
					push(@progress, $msg);
				}
			}
		} else {
			$corruptFile = 1;
			$msg = "        Error reading file $infile\r\n";
			push(@progress, $msg);
			push(@progress, $exception1 . "\n");
		}
    }

	#Checking the file sizes based on the closest found based on pixel size if specified as an option
	if ($opts{'f'}) {
		foreach $infile (keys %fileSizes) {
			if ($closestFileSize gt $fileSizes{$infile}) {
				if (($closestFileSize / $fileSizes{$infile}) gt (1 + $variance)) {
					$msg = sprintf("       WARNING: %s file size seems to exceed the variance (%4.1f%%) of the expected file size, %u.\r\n",$infile,($variance * 100),$closestFileSize);
					push(@progress, $msg);
				}
			} else {
				if (($fileSizes{$infile} / $closestFileSize) gt (1 + $variance)) {
					$msg = sprintf("        WARNING: %s file size seems to exceed the variance (%4.1f%%) of the expected file size, %u.\r\n",$infile,($variance * 100),$closestFileSize);
					push(@progress, $msg);
				}
			}
		}
   	}
   	
   	# Provide a note if no reading errors occurred.
   	if ($corruptFile == 0) {
   		$msg = "        All files appear to be readable/non-corrupt.\r\n";
   		push(@progress, $msg);
   	}
   	
   	if (not $ok) {
		next;
   	}
}
continue {
    if ($ok) {
	$msg = "    Directory '$dir' was processed successfully.\r\n\r\n";
	print $msg if ($opts{'v'});
	push(@progress, $msg);
    } else {
	$msg = "$me: ERROR: Processing of directory '$dir' FAILED!\r\n\r\n";
	warn $msg;
	push(@errors, $msg);
    }

    # change to starting directory
    if ( cwd() ne $startDir ) {
	if ( not chdir($startDir) ) {
	    $msg = "$me: FATAL ERROR: Cannot change to starting directory '$startDir': $!\r\n";
	    push(@errors, $msg);
	    Send_Mail();
	    die $msg;
	}
    }

}

$msg = "\nFinished at "  . (scalar localtime) . "\n";
push(@progress, $msg);

Send_Mail();


#======================================================================
# subroutines
#======================================================================

# Calculate the pixel length for an object based on its physical size and unit of measurement
sub sizeInPixels {
	my ($dimension,$unit,$dpi) = @_;
	my $pixels = 0;
	
	if ($unit eq 'cm') {
		$pixels = ($dimension / 2.54) * $dpi;
	} elsif ($units eq 'in') {
		$pixels = $dimension * $dpi;
	}
	return int($pixels);
}

# Sends email regarding the results of the script.
sub Send_Mail {

    my @time = localtime(time);
    my $today = $time[3];
    my $month = (1,2,3,4,5,6,7,8,9,10,11,12)[(localtime)[4]];
    my $year = $time[5];
    $year = $year - 100;

    $year = sprintf("%02d",$year);
    $month = sprintf("%02d",$month);
    $today = sprintf("%02d",$today);

    my($date)="$month/$today/$year";
    my($messageto) = $mailTo;

    open(MAIL,"| /usr/sbin/sendmail -i -t");
    print MAIL "To: $messageto\n"; 
    print MAIL "From: $mailFrom\n";
    if (@errors) {
	print MAIL "Subject: Error on image aspect ratio script\n\n";
	print MAIL "There was an error from the $me script on $date:\n\n";
    }
    else {
	print MAIL "Subject: Report on image aspect ratio script\n\n";
	print MAIL "$me script completed with no errors on $date.\n\n";
    }
    foreach my $err (@errors) {
	print MAIL "$err";
    }
    foreach my $noerr (@progress) {
	print MAIL "$noerr" ;
    }
    print MAIL "-" x 75 . "\n\n";
    close(MAIL);
}
